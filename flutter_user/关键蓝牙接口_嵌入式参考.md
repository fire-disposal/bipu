# 关键蓝牙接口（嵌入式端参考）

## 概述

本接口定义 Flutter 应用与嵌入式设备（如 ESP32）之间的 BLE 通信协议。协议设计遵循 **精简、低占用、健壮** 原则，仅保留核心功能：

1. **消息传输** – 通过 Nordic UART Service (NUS) 实现应用消息到设备的转发
2. **时间同步** – 通过 Current Time Service 将手机当前时间同步至设备

**已移除的功能**：电池电量传输（不再支持）。

## BLE 服务与特征

### 1. Nordic UART Service (NUS) – 消息转发
- **服务 UUID**: `6e400001-b5a3-f393-e0a9-e50e24dcca9e`

| 特征 | UUID | 属性 | 方向 | 描述 |
|------|------|------|------|------|
| TX (发送) | `6e400002-b5a3-f393-e0a9-e50e24dcca9e` | Write (Without Response) | 手机 → 设备 | 手机将消息数据写入该特征 |
| RX (接收) | `6e400003-b5a3-f393-e0a9-e50e24dcca9e` | Notify, Read | 设备 → 手机 | 设备可向手机发送响应（可选） |

### 2. Current Time Service – 时间同步
- **服务 UUID**: `00001805-0000-1000-8000-00805f9b34fb`

| 特征 | UUID | 属性 | 方向 | 描述 |
|------|------|------|------|------|
| Current Time | `00002a2b-0000-1000-8000-00805f9b34fb` | Write, Read | 手机 → 设备 | 手机写入 Exact Time 256 格式的时间数据 |

## 数据格式

### 2.1 消息数据格式
- **编码**: UTF‑8
- **最大长度**: 无限制（自动分块）
- **分块大小**: `MTU – 3` 字节（默认 MTU = 23，分块 = 20 字节）
- **示例**:
  ```
  原始消息: "Hello World"
  字节序列: [0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64]
  ```

### 2.2 时间数据格式（Exact Time 256）
- **长度**: 10 字节
- **字节序**: Little‑Endian
- **结构**:

| 字节偏移 | 字段 | 数据类型 | 说明 |
|----------|------|----------|------|
| 0‑1 | 年 | uint16 | 例如 2026 |
| 2 | 月 | uint8 | 1‑12 |
| 3 | 日 | uint8 | 1‑31 |
| 4 | 时 | uint8 | 0‑23 |
| 5 | 分 | uint8 | 0‑59 |
| 6 | 秒 | uint8 | 0‑59 |
| 7 | 星期 | uint8 | 1 = 星期一 … 7 = 星期日 |
| 8 | 毫秒高位 | uint8 | 毫秒 × 256 ÷ 1000（取整） |
| 9 | 调整原因 | uint8 | 固定为 0 |

**示例**（2026‑02‑13 18:30:45.123，星期五）:
```
字节: [0xE2 0x07, 0x02, 0x0D, 0x12, 0x1E, 0x2D, 0x05, 0x1F, 0x00]
解释: 年=2026 (0x07E2), 月=2, 日=13, 时=18, 分=30, 秒=45, 星期=5, 毫秒高位=31 (≈123ms), 调整=0
```

## 通信流程

### 3.1 连接建立
1. 设备广播 NUS 服务（可同时广播 Current Time 服务）
2. 手机扫描并连接设备
3. 连接成功后，手机自动发现服务与特征
4. 手机立即向 Current Time 特征写入当前时间（自动同步）

### 3.2 消息发送流程（手机 → 设备）
1. 应用层调用 `forwardMessage("消息内容")`
2. 服务层将消息按 UTF‑8 编码为字节数组
3. 根据当前 MTU 计算分块大小（MTU‑3）
4. 按分块依次写入 TX 特征（Write Without Response）
5. 设备端收到所有分块后重组为完整消息

### 3.3 时间同步流程
1. 手机在连接成功后自动调用 `syncTime()`
2. 获取当前系统时间并格式化为 10 字节 Exact Time 256 格式
3. 写入 Current Time 特征（Write With Response）
4. 设备收到时间数据后更新内部 RTC

## 错误处理与健壮性

- **特征检查**：写入前检查特征是否存在且具有写权限
- **异常捕获**：所有 BLE 操作均被 try‑catch 包裹，避免崩溃
- **调试日志**：在调试模式下输出失败信息（例如 `Failed to sync time: ...`）
- **连接状态**：连接断开后自动清理资源，准备下一次连接

## 嵌入式端实现要点

### 5.1 服务配置
- 必须实现 **Nordic UART Service**（TX、RX 特征）
- 建议实现 **Current Time Service**（Current Time 特征）
- 服务与特征 UUID 必须与上述定义完全一致

### 5.2 消息接收处理
- 接收 Write Without Response 写入的数据块
- 缓存并重组完整 UTF‑8 消息
- 可根据需要向 RX 特征写入响应（可选）

### 5.3 时间同步处理
- 监听 Current Time 特征的 Write 请求
- 解析 10 字节数据，更新设备内部时钟
- 忽略调整原因字段（保留未来扩展）

### 5.4 MTU 协商
- 建议在连接后协商较大的 MTU（例如 247 字节）以提高传输效率
- 若未协商，默认使用 23 字节 MTU，分块大小为 20 字节

## 技术参数

| 项目 | 值 |
|------|-----|
| BLE 版本 | 4.0+ |
| 默认 MTU | 23 字节 |
| 最大分块大小 | MTU‑3 字节 |
| 连接超时 | 15 秒 |
| 时间同步精度 | ±1 秒（受 BLE 传输延迟影响） |
| 消息传输速率 | 依赖 MTU 与连接间隔 |

## 示例代码（伪代码）

### 嵌入式端（ESP32 + NimBLE）
```c
// 初始化 NUS 服务
ble_uuid128_t nus_uuid = { .u = { .type = BLE_UUID_TYPE_128 } };
memcpy(nus_uuid.value, NUS_SERVICE_UUID, 16);
ble_gatts_add_svc(&nus_uuid, ...);

// 处理 TX 特征写入
static int on_write(uint16_t conn_handle, uint16_t attr_handle,
                    struct ble_gatt_access_ctxt *ctxt, void *arg) {
    // 接收数据块，重组消息
    // 调用业务层处理消息
    return 0;
}

// 处理 Current Time 写入
static int on_time_write(...) {
    // 解析 10 字节时间数据
    // 更新 RTC
    return 0;
}
```

### 手机端（Flutter）
参考 `BluetoothDeviceService` 类：
- `connect(device)` – 连接设备
- `syncTime()` – 同步时间
- `forwardMessage(text)` – 发送消息

## 版本历史

| 版本 | 日期 | 变更说明 |
|------|------|----------|
| 1.0 | 2026‑02‑13 | 初版，移除电池功能，优化时间同步与消息传输 |

---

**备注**：本接口为精简版本，旨在降低嵌入式端资源占用并提高通信可靠性。如需扩展功能（如设备状态上报、双向控制等），可在 NUS 的 RX 特征上定义相应协议。